<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>pyodbc</title>
    <link href="styles.css" rel="stylesheet">
  </head>
  <body>

    <div class="navbar">
      <div><a href="index.html">Overview</a></div>
      <div class="active"><a href="api.html">API</a></div>
      <div><a href="releases.html">Releases</a></div>
    </div>
    <div class="subnav">
      <div><a href="api-module.html">module</a></div>
      <div><a href="api-connection.html">connection</a></div>
      <div class="active"><a href="api-cursor.html">cursor</a></div>
      <div><a href="api-row.html">row</a></div>
      <div><a href="api-errors.html">errors</a></div>
    </div>

    <div class="container">

      <p>Cursors represent a database cursor (and map to ODBC HSTMTs), which is
        used to manage the context of a fetch operation.  Cursors created from
        the same connection are not isolated, i.e., any changes made to the
        database by a cursor are immediately visible by the other cursors.</p>

      <h1>variables</h1>

      <dl>

        <dt>description</dt>
        <dd>

          <p>This read-only attribute is a list of 7-item tuples, each
            containing <tt>(name, type_code, display_size, internal_size, precision,
            scale, null_ok)</tt>.  pyodbc only provides values for name, type_code,
            internal_size, and null_ok.  The other values are set to None.</p>

          <p>This attribute will be None for operations that do not return rows
            or if one of the execute methods has not been called.</p>

          <p>The type_code member is the class type used to create the Python
            objects when reading rows.  For example, a varchar column's type
            will be <tt>str</tt>.</p>
        </dd>

        <dt>rowcount</dt>
        <dd>
          <p>The number of rows modified by the previous DDL statement.</p>

          <p>This is -1 if no SQL has been executed or if the number of rows is
            unknown.  Note that it is not uncommon for databases to report -1
            after a select statement for performance reasons.  (The exact number
            may not be known before the first records are returned to the
            application.)</p>
        </dd>

      </dl>

      <h1 id=cursor_execute">execute</h1>

      <pre>cursor.execute(sql, *parameters) --> Cursor</pre>

      <dl>
        <dt>sql</dt>
        <dd>The SQL statement to execute with optional <code>?</code> parameter
          markers.  Note that pyodbc <em>never</em> modifies the SQL statement.</dd>

        <dt>parameters</dt>
        <dd>Optional parameters for the markers in the SQL.  They can be passed
        in a single sequence as defined by the DB API.  For convenience,
          however, they can also be passed individually.</dd>
      </dl>

<pre>
# as a sequence
cursor.execute("select a from tbl where b=? and c=?", <b>(x, y)</b>)

# passed individually
cursor.execute("select a from tbl where b=? and c=?", <b>x, y</b>)
</pre>

<p>You should use parameters when possible instead of inserting them directly
into the SQL to protect against <a
href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection attacks</a>.
Parameters are passed to the database <em>separately</em> using an ODBC
  parameter binding specifically designed for this.</p>

<p>The return value is always the cursor itself which allows chaining.</p>

<pre>
for row in cursor.execute("select user_id, user_name from users"):
    print()row.user_id, row.user_name)

row  = cursor.execute("select * from tmp")<b>.fetchone()</b>
rows = cursor.execute("select * from tmp")<b>.fetchall()</b>
val  = cursor.execute("select count(*) from tmp")<b>.fetchone()[0]</b>

count = cursor.execute("update users set last_logon=? where user_id=?", now, user_id)<b>.rowcount</b>
count = cursor.execute("delete from users where user_id=1")<b>.rowcount</b>
</pre>

<p>The last prepared statement is kept and reused if you execute the same SQL
again, making executing the same SQL with different parameters will be more
efficient.</p>

<h1 id="cursor_executemany">executemany</h1>

<pre>cursor.executemany(sql, seq_of_parameters) --> Cursor</pre>

<p>Executes the same SQL statement for each set of parameters.

  <dl>
    <dt>seq_of_parameters</dt>
    <dd>a sequence of sequences</dd>
  </dl>

<pre>
params = [ ('A', 1), ('B', 2) ]
executemany("insert into t(name, id) values (?, ?)", params)
</pre>

<p>This will execute the SQL statement twice, once with <code>('A', 1)</code>
  and once with <code>('B', 2)</code>.</p>

<h1 id="cursor_fetchval">fetchval</h1>

<pre>cursor.fetchval() --> value or None</pre>

<p>Returns the first column value from the next row or None if no more rows are available:</p>

<pre>
    cursor.execute("select count(*) from users")
    c = cursor.fetchval()
</pre>

<h1 id="cursor_fetchone">fetchone</h1>

<pre>cursor.fetchone() --> Row or None</pre>

<p>Returns the next <a href="#row">Row</a> or <tt>None</tt> if no more data is
available.</p>

<p>A ProgrammingError exception is raised if no SQL has been executed or if it
  did not return a result set (e.g. was not a SELECT statement).</p>

<pre>
cursor.execute("select user_name from users where user_id=?", userid)
row = cursor.fetchone()
if row:
    print(row.user_name)
</pre>

<h1 id="cursor_fetchall">fetchall</h1>

<pre>cursor.fetchall() --> list of rows</pre>

<p>Returns a list of all remaining <a href="#row">Rows</a>.  If there are no
more rows, an empty list is returned.</p>

<p>Since this reads all rows into memory, it should not be used if there are a
lot of rows.  Consider iterating over the rows instead.  However, it is useful
for freeing up a Cursor so you can perform a second query before processing the
resulting rows.</p>

<p>A ProgrammingError exception is raised if no SQL has been executed or if it
  did not return a result set (e.g. was not a SELECT statement).</p>

<pre>
cursor.execute("select user_id, user_name from users where user_id < 100")
rows = cursor.fetchall()
for row in rows:
    print(row.user_id, row.user_name)
</pre>

<h1 id="cursor_fetchmany">fetchmany</h1>

<pre>cursor.fetchmany([size=cursor.arraysize]) --> list of rows</pre>

<p>Similar to <a href="#cursor_fetchall">fetchall</a> but limits the returned
list size to <code>size</code>.  The default for cursor.arraysize is 1 which is
no different than calling <a href="#cursor_fetchone">fetchone</a>.</p>

<p>A ProgrammingError exception is raised if no SQL has been executed or if it
  did not return a result set (e.g. was not a SELECT statement).</p>


<h1 id="cursor_commit">commit</h1>

<pre>cursor.commit()</pre>

<p>A convenience function that calls commit on the Connection that created this
cursor.  Since <tt>cursor</tt> and <tt>commit</tt> is usually the only two
functions called on a connection, this function often allows you to work with
cursors only.</p>

<div class="alert alert-warning">
This affects all cursors created by the same connection.
</div>

<h1 id="cursor_rollback">rollback</h1>

<pre>cursor.rollback()</pre>

<p>A convenience function that calls commit on the Connection that created this
  cursor.</p>

<div class="alert alert-warning">
This affects all cursors created by the same connection.
</div>

<h1 id="cursor_skip">skip</h1>

<pre>cursor.skip(count)</pre>

<p>Skips the next <code>count</code> records by calling SQLFetchScroll with
  SQL_FETCH_NEXT.</p>

<p>For convenience, <tt>skip(0)</tt> is accepted and will do nothing.</p>

<h1 id="cursor_nextset">nextset</h1>

<pre>cursor.nextset() --> True or None</pre>

<p>This method will make the cursor skip to the next available set, discarding
  any remaining rows from the current set.</p>

<p>If there are no more sets, the method returns <tt>None</tt>. Otherwise, it
returns a true value and subsequent calls to the fetch methods will return rows
  from the next result set.</p>

<p>This method is useful if you have stored procedures that return multiple
results.  If your database supports it, you may be able to send multiple SQL
statements in a single batch and use this method to move through each result
set.</p>

<pre>cursor.execute("select * from users; select * from albumts")
users = cursor.fetchall()
cursor.nextset()
albums = cursor.fetchall()</pre>

<h1 id="cursor_close">close</h1>

<pre>cursor.close()</pre>

<p>Closes the cursor.  A ProgrammingError exception will be raised if any
  operation is attempted with the cursor.</p>

<p>Cursors are closed automatically when they are deleted, so calling this is
  not usually necessary when using C Python.</p>

<h1 id="cursor_callproc">callproc</h1>

<pre>cursor.callproc(procname[,parameters])</pre>

<p>This is not yet supported since there is no way for pyodbc to determine which
  parameters are input, output, or both.</p>

<p>You will need to call stored procedures using execute().  You can use your
  database's format or the ODBC escape format.</p>

<h1 id="cursor_tables">tables</h1>

<pre>cursor.tables(table=None, catalog=None, schema=None, tableType=None) --> Cursor</pre>

<p>Creates a result set of tables in the database that match the given criteria.</p>

<p>Each row has the following columns.  See the <a
  href="http://msdn.microsoft.com/en-us/library/ms711831.aspx">SQLTables</a>
  documentation for more information.</p>

<table>
  <thead>
    <tr><th>column</th><th>notes</th></tr>
  </thead>
  <tbody>
    <tr><td>table_cat</td><td>The catalog name.</td></tr>
    <tr><td>table_schem</td><td>The schema name.</td></tr>
    <tr><td>table_name</td><td>The table name.</td></tr>
    <tr><td>table_type</td><td>One of TABLE, VIEW, SYSTEM TABLE, GLOBAL TEMPORARY, LOCAL TEMPORARY, ALIAS, SYNONYM, or a data source-specific type name.</td></tr>
    <tr><td>remarks</td><td>A description of the table.</td></tr>
  </tbody>
</table>

<pre>
for row in cursor.tables():
    print(row.table_name)

# Does table 'x' exist?
if cursor.tables(table='x').fetchone():
   print('yes it does')
</pre>

<p>The table, catalog, and schema interpret the '_' and '%' characters as
  wildcards.  The escape character is driver specific, so use
  Connection.searchescape.</p>

<h1 id="cursor_columns">columns</h1>

<pre>cursor.columns(table=None, catalog=None, schema=None, column=None) --> Cursor</pre>

<p>Creates a result set of column information in the specified tables using the
  <a href="http://msdn.microsoft.com/en-us/library/ms711683%28VS.85%29.aspx">SQLColumns</a>
  function.</p>

<div class="toggle-top">
  <p><a href="#toggle-show">Click here to toggle the table of columns.</a></p>
  <table class="hide">
    <thead>
      <tr><th>column</th><th>notes</th></tr>
    </thead>
    <tbody>
      <tr><td>table_cat</td><td></td></tr>
      <tr><td>table_schem</td><td></td></tr>
      <tr><td>table_name</td><td></td></tr>
      <tr><td>column_name</td><td></td></tr>
      <tr><td>data_type</td><td></td></tr>
      <tr><td>type_name</td><td></td></tr>
      <tr><td>column_size</td><td></td></tr>
      <tr><td>buffer_length</td><td></td></tr>
      <tr><td>decimal_digits</td><td></td></tr>
      <tr><td>num_prec_radix</td><td></td></tr>
      <tr><td>nullable</td><td></td></tr>
      <tr><td>remarks</td><td></td></tr>
      <tr><td>column_def</td><td></td></tr>
      <tr><td>sql_data_type</td><td></td></tr>
      <tr><td>sql_datetime_sub</td><td></td></tr>
      <tr><td>char_octet_length</td><td></td></tr>
      <tr><td>ordinal_position</td><td></td></tr>
      <tr><td>is_nullable</td><td>One of the pyodbc constants SQL_NULLABLE, SQL_NO_NULLS, SQL_NULLS_UNKNOWN.</td></tr>
    </tbody>
  </table>
</div>

<pre>
# columns in table x
for row in cursor.columns(table='x'):
    print(row.column_name, 'is nullable?', row.is_nullable == pyodbc.SQL_NULLABLE)
</pre>

<h1 id="cursor_statistics">statistics</h1>

<pre>cursor.statistics(table, catalog=None, schema=None, unique=False, quick=True) --> Cursor</pre>

<p>Creates a result set of statistics about a single table and the indexes
  associated with the table by executing <a
  href="http://msdn.microsoft.com/en-us/library/ms711022%28VS.85%29.aspx">SQLStatistics</a>.</p>

<dl>
  <dt>unique</dt>
  <dd>If True only unique indexes are returned.  If False all indexes are returned.</dd>

  <dt>quick</dt>
  <dd>If True values for CARDINALITY and PAGES are returned only if they are
    readily available.  Otherwise <tt>None</tt> is returned for those
    columns.</dd>
</dl>

  <p>Each row has the following columns:</p>

<table>
  <thead>
    <tr><th>column</th></tr>
  </thead>
  <tbody>
    <tr><td>table_cat</td></tr>
    <tr><td>table_schem</td></tr>
    <tr><td>table_name</td></tr>
    <tr><td>non_unique</td></tr>
    <tr><td>index_qualifier</td></tr>
    <tr><td>index_name</td></tr>
    <tr><td>type</td></tr>
    <tr><td>ordinal_position</td></tr>
    <tr><td>column_name</td></tr>
    <tr><td>asc_or_desc</td></tr>
    <tr><td>cardinality</td></tr>
    <tr><td>pages</td></tr>
    <tr><td>filter_condition</td></tr>
  </tbody>
</table>

<h1 id="cursor_rowIdColumns">rowIdColumns</h1>

<pre>cursor.rowIdColumns(table, catalog=None, schema=None, nullable=True) --> Cursor</pre>

<p>Executes <a
  href="http://msdn.microsoft.com/en-us/library/ms714602%28VS.85%29.aspx">SQLSpecialColumns</a>
  with <tt>SQL_BEST_ROWID</tt> which creates a result set of columns that
  uniquely identify a row.</p>

<p>Each row has the following columns.</p>

<table>
  <thead>
    <tr><th>column</th><th>notes</th></tr>
  </thead>
  <tbody>
    <tr><td>scope</td><td>One of SQL_SCOPE_CURROW, SQL_SCOPE_TRANSACTION, or SQL_SCOPE_SESSION</td></tr>
    <tr><td>column_name</td></tr>
    <tr><td>data_type</td><td>The ODBC SQL data type constant (e.g. SQL_CHAR)</td></tr>
    <tr><td>type_name</td></tr>
    <tr><td>column_size</td></tr>
    <tr><td>buffer_length</td></tr>
    <tr><td>decimal_digits</td></tr>
    <tr><td>pseudo_column</td><td>One of SQL_PC_UNKNOWN, SQL_PC_NOT_PSEUDO, SQL_PC_PSEUDO</td></tr>
  </tbody>
</table>

<h1 id="cursor_rowVerColumns">rowVerColumns</h1>

  <pre>cursor.rowVerColumns(table, catalog=None, schema=None, nullable=True) --> Cursor</pre>

  <p>Executes <a
    href="http://msdn.microsoft.com/en-us/library/ms714602%28VS.85%29.aspx">SQLSpecialColumns</a>
    with <tt>SQL_ROWVER</tt> which creates a result set of columns that are
    automatically updated when any value in the row is updated.  Each row has
    the following columns.</p>

<table>
  <thead>
    <tr><th>keyword</th><th>converts to</th></tr>
  </thead>
  <tbody>
    <tr><td>scope</td><td>One of SQL_SCOPE_CURROW, SQL_SCOPE_TRANSACTION, or SQL_SCOPE_SESSION</td></tr>
    <tr><td>column_name</td></tr>
    <tr><td>data_type</td><td>The ODBC SQL data type constant (e.g. SQL_CHAR)</td></tr>
    <tr><td>type_name</td></tr>
    <tr><td>column_size</td></tr>
    <tr><td>buffer_length</td></tr>
    <tr><td>decimal_digits</td></tr>
    <tr><td>pseudo_column</td><td>One of SQL_PC_UNKNOWN, SQL_PC_NOT_PSEUDO, SQL_PC_PSEUDO</td></tr>
  </tbody>
</table>

<h1 id="cursor_primaryKeys">primaryKeys</h1>

  <pre>cursor.primaryKeys(table, catalog=None, schema=None) --> Cursor</pre>

<p>Creates a result set of column names that make up the primary key for a table
by executing the
<a href="http://msdn.microsoft.com/en-us/library/ms711005%28VS.85%29.aspx">
  SQLPrimaryKeys</h1> function.</a>

<p>Each row has the following columns:</p>

<table>
  <thead>
    <tr><th>column</th></tr>
  </thead>
  <tbody>
    <tr><td>table_cat</td></tr>
    <tr><td>table_schem</td></tr>
    <tr><td>table_name</td></tr>
    <tr><td>column_name</td></tr>
    <tr><td>key_seq</td></tr>
    <tr><td>pk_name</td></tr>
  </tbody>
</table>

<h1 id="cursor_foreignKeys">foreignKeys</h1>

<pre>cursor.foreignKeys(table=None, catalog=None, schema=None, foreignTable=None,
                   foreignCatalog=None, foreignSchema=None) --> Cursor</pre>

<p>Executes the <a
  href="http://msdn.microsoft.com/en-us/library/ms709315%28VS.85%29.aspx">
  SQLForeignKeys</a> function and creates a result set of column names that are
  foreign keys in the specified table (columns in the specified table that refer
  to primary keys in other tables) or foreign keys in other tables that refer to
  the primary key in the specified table.</p>

<p>Each row has the following columns:</p>

<table>
  <thead>
    <tr><th>column</th></tr>
  </thead>
  <tbody>
    <tr><td>pktable_cat</td></tr>
    <tr><td>pktable_schem</td></tr>
    <tr><td>pktable_name</td></tr>
    <tr><td>pkcolumn_name</td></tr>
    <tr><td>fktable_cat</td></tr>
    <tr><td>fktable_schem</td></tr>
    <tr><td>fktable_name</td></tr>
    <tr><td>fkcolumn_name</td></tr>
    <tr><td>key_seq</td></tr>
    <tr><td>update_rule</td></tr>
    <tr><td>delete_rule</td></tr>
    <tr><td>fk_name</td></tr>
    <tr><td>pk_name</td></tr>
    <tr><td>deferrability</td></tr>
  </tbody>
</table>

<h1 id="cursor_procedures">procedures</h1>

<pre>cursor.procedures(procedure=None, catalog=None, schema=None) --> Cursor</pre>

<p>Executes <a href="http://msdn.microsoft.com/en-us/library/ms715368%28VS.85%29.aspx">SQLProcedures</a>
and creates a result set of information about the procedures in the data source.  Each row has
  the following columns:</p>

<table>
  <thead>
    <tr><th>column</th></tr>
  </thead>
  <tbody>
    <tr><td>procedure_cat</td></tr>
    <tr><td>procedure_schem</td></tr>
    <tr><td>procedure_name</td></tr>
    <tr><td>num_input_params</td></tr>
    <tr><td>num_output_params</td></tr>
    <tr><td>num_result_sets</td></tr>
    <tr><td>remarks</td></tr>
    <tr><td>procedure_type</td></tr>
  </tbody>
</table>

<h1 id="cursor_getTypeInfo">getTypeInfo</h1>

<pre>cursor.getTypeInfo(sqlType=None) --> Cursor</pre>

<p>Executes <a href="http://msdn.microsoft.com/en-us/library/ms714632%28VS.85%29.aspx">SQLGetTypeInfo</a>
  a creates a result set with information about the specified data type or all
  data types supported by the ODBC driver if not specified.  Each row has the
  following columns:</p>

<table>
  <thead>
    <tr><th>column</th></tr>
  </thead>
  <tbody>
    <tr><td>type_name</td></tr>
    <tr><td>data_type</td></tr>
    <tr><td>column_size</td></tr>
    <tr><td>literal_prefix</td></tr>
    <tr><td>literal_suffix</td></tr>
    <tr><td>create_params</td></tr>
    <tr><td>nullable</td></tr>
    <tr><td>case_sensitive</td></tr>
    <tr><td>searchable</td></tr>
    <tr><td>unsigned_attribute</td></tr>
    <tr><td>fixed_prec_scale</td></tr>
    <tr><td>auto_unique_value</td></tr>
    <tr><td>local_type_name</td></tr>
    <tr><td>minimum_scale</td></tr>
    <tr><td>maximum_scale</td></tr>
    <tr><td>sql_data_type</td></tr>
    <tr><td>sql_datetime_sub</td></tr>
    <tr><td>num_prec_radix</td></tr>
    <tr><td>interval_precision</td></tr>
  </tbody>
</table>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="pyodbc.js"></script>
  </body>
</html>
