<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Pyodbc by mkleehammer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Pyodbc</h1>
      <h2 class="project-tagline">Python ODBC bridge</h2>
      <a href="https://github.com/mkleehammer/pyodbc" class="btn">View on GitHub</a>
      <a href="https://github.com/mkleehammer/pyodbc/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/mkleehammer/pyodbc/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h1>

<p>This project is a Python database module for ODBC that implements the Python DB API 2.0
specification.</p>

<p><a href="https://github.com/mkleehammer/pyodbc">https://github.com/mkleehammer/pyodbc</a></p>

<p>This module requires:</p>

<ul>
<li>Python 2.4 or greater</li>
<li>ODBC 3.0 or greater</li>
</ul>

<h1>
<a id="module-specific-behavior" class="anchor" href="#module-specific-behavior" aria-hidden="true"><span class="octicon octicon-link"></span></a>Module Specific Behavior</h1>

<h2>
<a id="general" class="anchor" href="#general" aria-hidden="true"><span class="octicon octicon-link"></span></a>General</h2>

<ul>
<li>
<p>The pyodbc.connect function accepts a single parameter: the ODBC connection string.  This
string is not read or modified by pyodbc, so consult the ODBC documentation or your ODBC
driver's documentation for details.  The general format is::</p>

<p>cnxn = pyodbc.connect('DSN=mydsn;UID=userid;PWD=pwd')</p>
</li>
<li><p>Connection caching in the ODBC driver manager is automatically enabled.</p></li>
<li><p>Call cnxn.commit() since the DB API specification requires a rollback when a connection
is closed that was not specifically committed.</p></li>
<li><p>When a connection is closed, all cursors created from the connection are closed.</p></li>
</ul>

<h2>
<a id="data-types" class="anchor" href="#data-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Types</h2>

<ul>
<li><p>Dates, times, and timestamps use the Python datetime module's date, time, and datetime
classes.  These classes can be passed directly as parameters and will be returned when
querying date/time columns.</p></li>
<li><p>Binary data is passed and returned in Python buffer objects.</p></li>
<li><p>Decimal and numeric columns are passed and returned using the Python 2.4 decimal class.</p></li>
</ul>

<h2>
<a id="convenient-additions" class="anchor" href="#convenient-additions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Convenient Additions</h2>

<ul>
<li>
<p>Cursors are iterable and returns Row objects.</p>

<p>::</p>

<p>cursor.execute("select a,b from tmp")
  for row in cursor:
      print row</p>
</li>
<li>
<p>The DB API specifies that results must be tuple-like, so columns are normally accessed by
indexing into the sequence (e.g. row[0]) and pyodbc supports this. However, columns can also
be accessed by name::</p>

<p>cursor.execute("select album_id, photo_id from photos where user_id=1")
  row = cursor.fetchone()
  print row.album_id, row.photo_id
  print row[0], row[1] # same as above, but less readable</p>

<p>This makes the code easier to maintain when modifying SQL, more readable, and allows rows to
be used where a custom class might otherwise be used. All rows from a single execute share
the same dictionary of column names, so using Row objects to hold a large result set may also
use less memory than creating a object for each row.</p>

<p>The SQL "as" keyword allows the name of a column in the result set to be specified. This is
useful if a column name has spaces or if there is no name::</p>

<p>cursor.execute("select count(*) as photo_count from photos where user_id &lt; 100")
  row = cursor.fetchone()
  print row.photo_count</p>
</li>
<li>
<p>The DB API specification does not specify the return value of Cursor.execute. Previous
versions of pyodbc (2.0.x) returned different values, but the 2.1 versions always return the
Cursor itself.</p>

<p>This allows for compact code such as::</p>

<p>for row in cursor.execute("select album_id, photo_id from photos where user_id=1"):
      print row.album_id, row.photo_id</p>

<p>row  = cursor.execute("select * from tmp").fetchone()
  rows = cursor.execute("select * from tmp").fetchall()</p>

<p>count = cursor.execute("update photos set processed=1 where user_id=1").rowcount
  count = cursor.execute("delete from photos where user_id=1").rowcount</p>
</li>
<li>
<p>Though SQL is very powerful, values sometimes need to be modified before they can be
used. Rows allow their values to be replaced, which makes them even more convenient ad-hoc
data structures.</p>

<p>::</p>

<p># Replace the 'start_date' datetime in each row with one that has a time zone.
  rows = cursor.fetchall()
  for row in rows:
      row.start_date = row.start_date.astimezone(tz)</p>

<p>Note that columns cannot be added to rows; only values for existing columns can be modified.</p>
</li>
<li>
<p>As specified in the DB API, Cursor.execute accepts an optional sequence of parameters::</p>

<p>cursor.execute("select a from tbl where b=? and c=?", (x, y))</p>

<p>However, this seems complicated for something as simple as passing parameters, so pyodbc also
accepts the parameters directly. Note in this example that x &amp; y are not in a tuple::</p>

<p>cursor.execute("select a from tbl where b=? and c=?", x, y)</p>
</li>
<li>
<p>The DB API specifies that connections require a manual commit and pyodbc complies with
this. However, connections also support autocommit, using the autocommit keyword of the
connection function or the autocommit attribute of the Connection object::</p>

<p>cnxn = pyodbc.connect(cstring, autocommit=True)</p>

<p>or</p>

<p>::</p>

<p>cnxn.autocommit = True
  cnxn.autocommit = False</p>
</li>
</ul>

<h1>
<a id="goals--design" class="anchor" href="#goals--design" aria-hidden="true"><span class="octicon octicon-link"></span></a>Goals / Design</h1>

<ul>
<li><p>This module should not require any 3rd party modules other than ODBC.</p></li>
<li>
<p>Only built-in data types should be used where possible.</p>

<p>a) Reduces the number of libraries to learn.</p>

<p>b) Reduces the number of modules and libraries to install.</p>

<p>c) Eventually a standard is usually introduced.  For example, many previous database drivers
   used the mxDate classes.  Now that Python 2.3 has introduced built-in date/time classes,
   using those modules is more complicated than using the built-ins.</p>
</li>
<li><p>It should adhere to the DB API specification, but be more "Pythonic" when convenient.
The most common usages should be optimized for convenience and speed.</p></li>
<li><p>All ODBC functionality should (eventually) be exposed.</p></li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mkleehammer/pyodbc">Pyodbc</a> is maintained by <a href="https://github.com/mkleehammer">mkleehammer</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

