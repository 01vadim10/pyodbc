<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>pyodbc</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet">
  </head>
  <body>

    <div class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../" class="navbar-brand">pyodbc</a>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="index.html">Overview</a></li>
            <li><a href="releases.html">Releases</a></li>
            <li><a href="api.html">API</a></li>
            <!-- <li><a href="faq.html">FAQ</a></li> -->
          </ul>
        </nav>
      </div>
    </div>

    <div class="container">
      <h1>Overview</h1>

      <ul>
        <li><a href="#installing">Installing</a></li>
        <li><a href="#getting-started">Getting Started</a></li>
        <ul>
          <li><a href="#connecting">Connect To A Database</a></li>
          <li><a href="#select">Select Some Data</a></li>
          <li><a href="#params">Parameters</a></li>
          <li><a href="#insert">Insert Data</a></li>
          <li><a href="#update">Update and Delete</a></li>
        </ul>
        <li><a href="#tips">Tips and Tricks</a></li>
      </ul>

      <p>pyodbc is an open source Python module that makes accessing ODBC
        databases simple.  It implements the
        <a href="https://www.python.org/dev/peps/pep-0249/">DB API 2.0
        specification</a> but is packed with even more Pythonic convenience.</p>

      <h2 id="installing">Installing</h2>

      <p>The easiest way to install is using pip.  Windows binaries will be
        downloaded but other operating systems will need to compile from
        source.</p>

      <pre>pip install pyodbc</pre>

      <p>Development is on GitHub:
        <a href="https://github.com/mkleehammer/pyodbc">https://github.com/mkleehammer/pyodbc</a>
      </p>

      <h2 id="getting-started">Getting Started</h2>

      <h3 id="connecting">Connect to A Database</h3>

      <p>Pass an <a href="https://github.com/mkleehammer/pyodbc/wiki">ODBC connection string</a> to
        the <a href="api.html#connect">connect</a> function which will return a <a
        href="api.html#connection">Connection</a>.  Once you have a connection
        you can ask it for a <a href="api.html#cursor">Cursor</a>. Several connection examples
        are provided below.</p>

<pre>
# Connection example: Windows, without a DSN, using the Windows SQL Server driver
cnxn = pyodbc.connect('DRIVER={SQL Server};SERVER=localhost;PORT=1433;DATABASE=testdb;UID=me;PWD=pass')
</pre>

<pre>
# Connection example: Linux, without a DSN, using the FreeTDS driver
cnxn = pyodbc.connect('DRIVER={FreeTDS};SERVER=localhost;PORT=1433;DATABASE=testdb;UID=me;PWD=pass;TDS_Version=7.0')
</pre>

<pre>
# Connection example: with a DSN
cnxn = pyodbc.connect('DSN=test;PWD=password')
</pre>

<pre>
# Opening a cursor
cursor = cnxn.cursor()
</pre>

<p>The parameter is a standard
  so the keywords depend on the driver you are using.</p>

<h3 id="select">Select Some Data</h3>

<p>All SQL statements are executed using <a
href="api.html#cursor_execute">Cursor.execute</a>.  If the statement returns
rows, such as a select statement, you can retreive them using the Cursor fetch
functions (<a href="api.html#cursor_fetchone">fetchone</a>, <a
href="api.html#cursor_fetchall">fetchall</a>, <a
href="api.html#cursor_fetchmany">fetchmany</a>).</p>

<p>Cursor.fetchone is used to return a single <a href="api.html#row">Row</a>.</p>

  <pre>cursor.execute("select user_id, user_name from users")
row = cursor.fetchone()
if row:
    print(row)</pre>

  <p><a href="api.htm.row">Row</a> objects are similar to tuples, but they also
    allow access to columns by name:</p>

    <pre>cursor.execute("select user_id, user_name from users")
row = cursor.fetchone()
print('name:', row[1])         # access by column index
print('name:', row.user_name)  # or access by name</pre>

    <p><tt>fetchone</tt> returns <tt>None</tt> when all rows have been retrieved.</p>

  <pre>while 1:
    row = cursor.fetchone()
    if not row:
        break
    print('id:', row.user_id)</pre>

  <p><a href="api.html#cursor_fetchall">Cursor.fetchall</a> returns all
remaining rows in a list.  If there are no rows, an empty list is returned.  (If
there are a lot of rows, this will use a lot of memory.  Unread rows are stored
by the database driver in a compact format and are often sent in batches from
the database server.  Reading in only the rows you need at one time will save a
lot of memory.)</p>

    <pre>cursor.execute("select user_id, user_name from users")
rows = cursor.fetchall()
for row in rows:
    print(row.user_id, row.user_name)</pre>

    <p>If you are going to process the rows one at a time, you can use the
      cursor itself as an iterator:</p>

  <pre>cursor.execute("select user_id, user_name from users"):
for row in cursor:
    print(row.user_id, row.user_name)</pre>

  <p>Since <tt>Cursor.execute</tt> always returns the cursor, you can simplify
    this even more:</p>

<pre>for row in cursor.execute("select user_id, user_name from users"):
    print(row.user_id, row.user_name)</pre>

<p>A lot of SQL statements are not very readable on a single line, which is
  where Python's triple quoted strings really shine:</p>

  <pre>cursor.execute(
    """
    select user_id, user_name
      from users
     where last_logon < '2001-01-01'
           and bill_overdue = 1
    """)</pre>

  <h3 id="params">Parameters</h3>

  <p>ODBC supports query parameters using a question mark as a place holder in the
    SQL.  You provide the values for the question marks by passing them after
    the SQL:</p>

<pre>cursor.execute(
    """
    select user_id, user_name
      from users
     where last_logon < ?
           and bill_overdue = ?
    """, '2001-01-01', 1)</pre>

<p>This is safer than putting the values into the string because the parameters
  are passed to the database separately, protecting against
  <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection attacks</a>.
  It is also more efficient if you execute the same SQL repeatedly with different
  parameters.  The SQL will be
  <a href="http://en.wikipedia.org/wiki/Prepared_statements#Parameterized_statements">
    prepared</a> only once.  (pyodbc only keeps the last statement prepared, so if you
  switch between statements, each will be prepared multiple times.)</p>

<p>The Python DB API specifies that parameters should be passed in a sequence,
  so this is also supported by pyodbc:</p>

  <pre>cursor.execute(
    """
    select user_id, user_name
      from users
     where last_logon < ?
           and bill_overdue = ?
    """, ['2001-01-01', 1])</pre>

<h3 id="insert">Insert Data</h3>

<p>Inserting data uses the same function - pass the insert SQL to execute along with any parameters.</p>

  <pre>cursor.execute("insert into products(id, name) values ('pyodbc', 'awesome library')")
cnxn.commit()</pre>

    <pre>cursor.execute("insert into products(id, name) values (?, ?)", 'pyodbc', 'awesome library')
cnxn.commit()</pre>

    <p>Note the calls to <a href="api.html#connection_commit">cnxn.commit()</a>.
       Connections maintain a transaction that is rolled back if commit is not
      called.  This makes error recovery easy (and finally is not needed).</p>

    <div class="alert alert-warning">
      You must call <a href="api.html#connection_commit">commit</a> or your changes will be lost!
    </div>

    <h3 id="update">Update and Delete</h3>

    <p>Updating and deleting work the same way: pass the SQL to execute.
However, you often want to know how many records were affected when updating and
deleting, in which case you can use <a
href="api.html#cursor_rowcount">Cursor.rowcount</a> value:</p>

  <pre>cursor.execute("delete from products where id <> ?", 'pyodbc')
print('Deleted {} inferior products'.format(cursor.rowcount))
cnxn.commit()</pre>

  <p>Since <tt>execute</tt> returns the cursor (allowing you to chain calls or
  use in an iterator), you will sometimes see code with
    rowcount on the end:</p>

<pre>deleted = cursor.execute("delete from products where id <> 'pyodbc'")<b>.rowcount</b>
cnxn.commit()</pre>

  <div class="alert alert-warning">
    You must call <a href="api.html#connection_commit">commit</a> or your changes will be lost!
  </div>

  <h2 id="tips">Tips and Tricks</h2>

  <h3>Quotes</h3>

  <p>Since single quotes are valid in SQL, use double quotes to surround your SQL:</p>

  <pre>cursor.execute("delete from products where id <> 'pyodbc'")</pre>

  <p>If you are using triple quotes, you can use either:</p>

    <pre>cursor.execute(
    """
    delete
      from products
     where id <> 'pyodbc'
    """)</pre>

    <h3>Column names</h3>

    <p>Some databases like Microsoft SQL Server do not generate column names for
calculations, in which case you need to access the columns by index.  You can
also use the 'as' keyword to name columns (the "as user_count" in the SQL
below).</p>

    <pre>row = cursor.execute("select count(*) <b>as user_count</b> from users").fetchone()
print('{} users'.format(row.user_count)</pre>

    <p>Of course you can always extract the value by index:</p>

    <pre>count = cursor.execute("select count(*) from users").<b>fetchone()[0]</b>
print('{} users'.format(count)</pre>

    <p>This will not work if the first column can be <tt>NULL</tt>.  In that
      case, <tt>fetchone</tt> will return <tt>None</tt>and you'll get a cryptic
      error about <tt>NoneType</tt> not supporting indexing.  If there is a
      default value, often you can is <tt>ISNULL</tt> or <tt>coalesce</tt>:</p>

<pre>maxid = cursor.execute("select <b>coalesce(max(id), 0)</b> from users").fetchone()[0]</pre>

<h3>Automatic Cleanup</h3>

<p>Connections (by default) are always in a transaction.  If a connection is
  closed without being committed, the current transaction is rolled back.
  Because connections are closed immediately when they go out of scope (due to C
  Python's reference counting implementation) cleanup rarely requires
  <tt>except</tt> or <tt>finally</tt> clauses.</p>

<p>For example, if either of the SQL statements fails in the example below, an
  exception would be raised causing both the connection cursor to go out of
  scope as the exception leaves the function and unwinds the stack.  Either both
  inserts take place or neither, all with no clean up code to write.</p>

<pre>cnxn = pyodbc.connect(...)
cursor = cnxn.cursor()
cursor.execute("insert into t(col) values (1)")
cursor.execute("insert into t(col) values (2)")
cnxn.commit()</pre>

    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
  </body>
</html>
