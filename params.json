{"name":"Pyodbc","tagline":"Python ODBC bridge","body":"\r\nOverview\r\n========\r\n\r\nThis project is a Python database module for ODBC that implements the Python DB API 2.0\r\nspecification.\r\n\r\nhttps://github.com/mkleehammer/pyodbc\r\n\r\nThis module requires:\r\n\r\n* Python 2.4 or greater\r\n* ODBC 3.0 or greater\r\n\r\nModule Specific Behavior\r\n========================\r\n\r\nGeneral\r\n-------\r\n\r\n* The pyodbc.connect function accepts a single parameter: the ODBC connection string.  This\r\n  string is not read or modified by pyodbc, so consult the ODBC documentation or your ODBC\r\n  driver's documentation for details.  The general format is::\r\n\r\n    cnxn = pyodbc.connect('DSN=mydsn;UID=userid;PWD=pwd')\r\n\r\n* Connection caching in the ODBC driver manager is automatically enabled.\r\n\r\n* Call cnxn.commit() since the DB API specification requires a rollback when a connection\r\n  is closed that was not specifically committed.\r\n\r\n* When a connection is closed, all cursors created from the connection are closed.\r\n\r\n\r\nData Types\r\n----------\r\n\r\n* Dates, times, and timestamps use the Python datetime module's date, time, and datetime\r\n  classes.  These classes can be passed directly as parameters and will be returned when\r\n  querying date/time columns.\r\n\r\n* Binary data is passed and returned in Python buffer objects.\r\n\r\n* Decimal and numeric columns are passed and returned using the Python 2.4 decimal class.\r\n\r\n\r\nConvenient Additions\r\n--------------------\r\n\r\n* Cursors are iterable and returns Row objects.\r\n\r\n  ::\r\n\r\n    cursor.execute(\"select a,b from tmp\")\r\n    for row in cursor:\r\n        print row\r\n\r\n\r\n* The DB API specifies that results must be tuple-like, so columns are normally accessed by\r\n  indexing into the sequence (e.g. row[0]) and pyodbc supports this. However, columns can also\r\n  be accessed by name::\r\n\r\n    cursor.execute(\"select album_id, photo_id from photos where user_id=1\")\r\n    row = cursor.fetchone()\r\n    print row.album_id, row.photo_id\r\n    print row[0], row[1] # same as above, but less readable\r\n\r\n  This makes the code easier to maintain when modifying SQL, more readable, and allows rows to\r\n  be used where a custom class might otherwise be used. All rows from a single execute share\r\n  the same dictionary of column names, so using Row objects to hold a large result set may also\r\n  use less memory than creating a object for each row.\r\n\r\n  The SQL \"as\" keyword allows the name of a column in the result set to be specified. This is\r\n  useful if a column name has spaces or if there is no name::\r\n\r\n    cursor.execute(\"select count(*) as photo_count from photos where user_id < 100\")\r\n    row = cursor.fetchone()\r\n    print row.photo_count\r\n\r\n\r\n* The DB API specification does not specify the return value of Cursor.execute. Previous\r\n  versions of pyodbc (2.0.x) returned different values, but the 2.1 versions always return the\r\n  Cursor itself.\r\n\r\n  This allows for compact code such as::\r\n\r\n    for row in cursor.execute(\"select album_id, photo_id from photos where user_id=1\"):\r\n        print row.album_id, row.photo_id\r\n     \r\n    row  = cursor.execute(\"select * from tmp\").fetchone()\r\n    rows = cursor.execute(\"select * from tmp\").fetchall()\r\n     \r\n    count = cursor.execute(\"update photos set processed=1 where user_id=1\").rowcount\r\n    count = cursor.execute(\"delete from photos where user_id=1\").rowcount\r\n\r\n\r\n* Though SQL is very powerful, values sometimes need to be modified before they can be\r\n  used. Rows allow their values to be replaced, which makes them even more convenient ad-hoc\r\n  data structures.\r\n\r\n  ::\r\n\r\n    # Replace the 'start_date' datetime in each row with one that has a time zone.\r\n    rows = cursor.fetchall()\r\n    for row in rows:\r\n        row.start_date = row.start_date.astimezone(tz)\r\n\r\n  Note that columns cannot be added to rows; only values for existing columns can be modified.\r\n\r\n\r\n* As specified in the DB API, Cursor.execute accepts an optional sequence of parameters::\r\n\r\n    cursor.execute(\"select a from tbl where b=? and c=?\", (x, y))\r\n\r\n  However, this seems complicated for something as simple as passing parameters, so pyodbc also\r\n  accepts the parameters directly. Note in this example that x & y are not in a tuple::\r\n\r\n    cursor.execute(\"select a from tbl where b=? and c=?\", x, y)\r\n\r\n* The DB API specifies that connections require a manual commit and pyodbc complies with\r\n  this. However, connections also support autocommit, using the autocommit keyword of the\r\n  connection function or the autocommit attribute of the Connection object::\r\n\r\n    cnxn = pyodbc.connect(cstring, autocommit=True)\r\n\r\n  or\r\n\r\n  ::\r\n\r\n    cnxn.autocommit = True\r\n    cnxn.autocommit = False\r\n\r\n\r\nGoals / Design\r\n==============\r\n\r\n* This module should not require any 3rd party modules other than ODBC.\r\n\r\n* Only built-in data types should be used where possible.\r\n\r\n  a) Reduces the number of libraries to learn.\r\n\r\n  b) Reduces the number of modules and libraries to install.\r\n\r\n  c) Eventually a standard is usually introduced.  For example, many previous database drivers\r\n     used the mxDate classes.  Now that Python 2.3 has introduced built-in date/time classes,\r\n     using those modules is more complicated than using the built-ins.\r\n\r\n* It should adhere to the DB API specification, but be more \"Pythonic\" when convenient.\r\n  The most common usages should be optimized for convenience and speed.\r\n\r\n* All ODBC functionality should (eventually) be exposed.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}